#include <iostream>
#include <string>
#include <cstdlib>
#include <cstdint>
#include <map>
#include <utility>
#include <algorithm>
#include <array>
#include <vector>
#include <stdlib.h>



uint8_t HexCharToUint(char c) {
    switch (c) {
        case '0' : return 0b00000000;
        case '1' : return 0b00000001;
        case '2' : return 0b00000010;
        case '3' : return 0b00000011;
        case '4' : return 0b00000100;
        case '5' : return 0b00000101;
        case '6' : return 0b00000110;
        case '7' : return 0b00000111;
        case '8' : return 0b00001000;
        case '9' : return 0b00001001;
        case 'a' : return 0b00001010;
        case 'b' : return 0b00001011;
        case 'c' : return 0b00001100;
        case 'd' : return 0b00001101;
        case 'e' : return 0b00001110;
        case 'f' : return 0b00001111;
        default: std::exit(1);
    }
}

char UintToHexChar(uint8_t u) {
    switch (u) {
        case 0b00000000: return '0';
        case 0b00000001: return '1';
        case 0b00000010: return '2';
        case 0b00000011: return '3';
        case 0b00000100: return '4';
        case 0b00000101: return '5';
        case 0b00000110: return '6';
        case 0b00000111: return '7';
        case 0b00001000: return '8';
        case 0b00001001: return '9';
        case 0b00001010: return 'a';
        case 0b00001011: return 'b';
        case 0b00001100: return 'c';
        case 0b00001101: return 'd';
        case 0b00001110: return 'e';
        case 0b00001111: return 'f';
        default: std::exit(1);
    }
}

std::string StringToHexString(const std::string& s) {
    std::string res{};
    res.reserve(2 * s.length());

    for (char c : s) {
        res.push_back(UintToHexChar((static_cast<uint8_t>(c) & 0xF0) >> 4));
        res.push_back(UintToHexChar(static_cast<uint8_t>(c) & 0x0F));
    }

    return res;
}

std::string Base64ToHex(const std::string& base64_string) {
    const std::map<char, uint8_t> lookup_table{{ 
        {'A', 0b00000000}, {'B', 0b00000001}, {'C', 0b00000010}, {'D', 0b00000011}, {'E', 0b00000100}, {'F', 0b00000101}, {'G', 0b00000110}, {'H', 0b00000111}, 
        {'I', 0b00001000}, {'J', 0b00001001}, {'K', 0b00001010}, {'L', 0b00001011}, {'M', 0b00001100}, {'N', 0b00001101}, {'O', 0b00001110}, {'P', 0b00001111},
        {'Q', 0b00010000}, {'R', 0b00010001}, {'S', 0b00010010}, {'T', 0b00010011}, {'U', 0b00010100}, {'V', 0b00010101}, {'W', 0b00010110}, {'X', 0b00010111}, 
        {'Y', 0b00011000}, {'Z', 0b00011001}, {'a', 0b00011010}, {'b', 0b00011011}, {'c', 0b00011100}, {'d', 0b00011101}, {'e', 0b00011110}, {'f', 0b00011111},
        {'g', 0b00100000}, {'h', 0b00100001}, {'i', 0b00100010}, {'j', 0b00100011}, {'k', 0b00100100}, {'l', 0b00100101}, {'m', 0b00100110}, {'n', 0b00100111}, 
        {'o', 0b00101000}, {'p', 0b00101001}, {'q', 0b00101010}, {'r', 0b00101011}, {'s', 0b00101100}, {'t', 0b00101101}, {'u', 0b00101110}, {'v', 0b00101111},
        {'w', 0b00110000}, {'x', 0b00110001}, {'y', 0b00110010}, {'z', 0b00110011}, {'0', 0b00110100}, {'1', 0b00110101}, {'2', 0b00110110}, {'3', 0b00110111}, 
        {'4', 0b00111000}, {'5', 0b00111001}, {'6', 0b00111010}, {'7', 0b00111011}, {'8', 0b00111100}, {'9', 0b00111101}, {'+', 0b00111110}, {'/', 0b00111111}
    }};
    
    std::string res{};
    res.reserve((3 * base64_string.length() + 1) / 2);
    
    bool flip_flop = true;;
    uint8_t remainder = 0;

    for (char c : base64_string) {
        if (c == '=') {
            if (flip_flop && base64_string.back() == '=') {
                res.pop_back();
            }
            
            break;
        }

        std::map<char, uint8_t>::const_iterator iter = lookup_table.find(c);
        if (iter == lookup_table.end()) {
            std::exit(1);
        }

        uint8_t u = iter->second;
        
        if (flip_flop) {
            res.push_back(UintToHexChar((u & 0b00111100) >> 2));
            remainder = u & 0b00000011;
        } else {
            res.push_back(UintToHexChar(((u & 0b00110000) >> 4) | (remainder << 2)));
            res.push_back(UintToHexChar(u & 0b00001111));
        }

        flip_flop = !flip_flop;
    }

    return res;
}

std::array<uint8_t, 16> AES128AddRoundKey(const std::array<uint8_t, 16>& state, const std::array<uint8_t, 16>& key) {
    std::array<uint8_t, 16> res{};

    for (size_t i = 0; i < 16; i++) {
        res[i] = state[i] ^ key[i];
    }

    return res;
}

std::array<uint8_t, 16> AES128SubBytes(const std::array<uint8_t, 16>& state) {
    const std::array<uint8_t, 256> rijandael_s_box{0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};

    std::array<uint8_t, 16> res{};

    for (size_t i = 0; i < 16; i++) {
        res[i] = rijandael_s_box[state[i]];
    }

    return res;
}

std::array<uint8_t, 16> AES128ShiftRows(const std::array<uint8_t, 16>& state) {
    return std::array<uint8_t, 16>{
        state[0],  state[5],  state[10], state[15],
        state[4],  state[9],  state[14], state[3],
        state[8],  state[13], state[2],  state[7],
        state[12], state[1],  state[6],  state[11]
    };
}

std::array<uint8_t, 16> AES128MixColumns(const std::array<uint8_t, 16>& state) {
    const std::array<uint8_t, 256> multiply_by_2{0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E, 0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE, 0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE, 0x1B, 0x19, 0x1F, 0x1D, 0x13, 0x11, 0x17, 0x15, 0x0B, 0x09, 0x0F, 0x0D, 0x03, 0x01, 0x07, 0x05, 0x3B, 0x39, 0x3F, 0x3D, 0x33, 0x31, 0x37, 0x35, 0x2B, 0x29, 0x2F, 0x2D, 0x23, 0x21, 0x27, 0x25, 0x5B, 0x59, 0x5F, 0x5D, 0x53, 0x51, 0x57, 0x55, 0x4B, 0x49, 0x4F, 0x4D, 0x43, 0x41, 0x47, 0x45, 0x7B, 0x79, 0x7F, 0x7D, 0x73, 0x71, 0x77, 0x75, 0x6B, 0x69, 0x6F, 0x6D, 0x63, 0x61, 0x67, 0x65, 0x9B, 0x99, 0x9F, 0x9D, 0x93, 0x91, 0x97, 0x95, 0x8B, 0x89, 0x8F, 0x8D, 0x83, 0x81, 0x87, 0x85, 0xBB, 0xB9, 0xBF, 0xBD, 0xB3, 0xB1, 0xB7, 0xB5, 0xAB, 0xA9, 0xAF, 0xAD, 0xA3, 0xA1, 0xA7, 0xA5, 0xDB, 0xD9, 0xDF, 0xDD, 0xD3, 0xD1, 0xD7, 0xD5, 0xCB, 0xC9, 0xCF, 0xCD, 0xC3, 0xC1, 0xC7, 0xC5, 0xFB, 0xF9, 0xFF, 0xFD, 0xF3, 0xF1, 0xF7, 0xF5, 0xEB, 0xE9, 0xEF, 0xED, 0xE3, 0xE1, 0xE7, 0xE5};
    const std::array<uint8_t, 256> multiply_by_3{0x00, 0x03, 0x06, 0x05, 0x0C, 0x0F, 0x0A, 0x09, 0x18, 0x1B, 0x1E, 0x1D, 0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3C, 0x3F, 0x3A, 0x39, 0x28, 0x2B, 0x2E, 0x2D, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65, 0x6C, 0x6F, 0x6A, 0x69, 0x78, 0x7B, 0x7E, 0x7D, 0x74, 0x77, 0x72, 0x71, 0x50, 0x53, 0x56, 0x55, 0x5C, 0x5F, 0x5A, 0x59, 0x48, 0x4B, 0x4E, 0x4D, 0x44, 0x47, 0x42, 0x41, 0xC0, 0xC3, 0xC6, 0xC5, 0xCC, 0xCF, 0xCA, 0xC9, 0xD8, 0xDB, 0xDE, 0xDD, 0xD4, 0xD7, 0xD2, 0xD1, 0xF0, 0xF3, 0xF6, 0xF5, 0xFC, 0xFF, 0xFA, 0xF9, 0xE8, 0xEB, 0xEE, 0xED, 0xE4, 0xE7, 0xE2, 0xE1, 0xA0, 0xA3, 0xA6, 0xA5, 0xAC, 0xAF, 0xAA, 0xA9, 0xB8, 0xBB, 0xBE, 0xBD, 0xB4, 0xB7, 0xB2, 0xB1, 0x90, 0x93, 0x96, 0x95, 0x9C, 0x9F, 0x9A, 0x99, 0x88, 0x8B, 0x8E, 0x8D, 0x84, 0x87, 0x82, 0x81, 0x9B, 0x98, 0x9D, 0x9E, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8F, 0x8C, 0x89, 0x8A, 0xAB, 0xA8, 0xAD, 0xAE, 0xA7, 0xA4, 0xA1, 0xA2, 0xB3, 0xB0, 0xB5, 0xB6, 0xBF, 0xBC, 0xB9, 0xBA, 0xFB, 0xF8, 0xFD, 0xFE, 0xF7, 0xF4, 0xF1, 0xF2, 0xE3, 0xE0, 0xE5, 0xE6, 0xEF, 0xEC, 0xE9, 0xEA, 0xCB, 0xC8, 0xCD, 0xCE, 0xC7, 0xC4, 0xC1, 0xC2, 0xD3, 0xD0, 0xD5, 0xD6, 0xDF, 0xDC, 0xD9, 0xDA, 0x5B, 0x58, 0x5D, 0x5E, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4F, 0x4C, 0x49, 0x4A, 0x6B, 0x68, 0x6D, 0x6E, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7F, 0x7C, 0x79, 0x7A, 0x3B, 0x38, 0x3D, 0x3E, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2F, 0x2C, 0x29, 0x2A, 0x0B, 0x08, 0x0D, 0x0E, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1F, 0x1C, 0x19, 0x1A};

    std::array<uint8_t, 16> res{};
    
    for (size_t i = 0; i < 4; i++) {
        uint8_t u0 = state[4 * i + 0];
        uint8_t u1 = state[4 * i + 1];
        uint8_t u2 = state[4 * i + 2];
        uint8_t u3 = state[4 * i + 3];

        res[4 * i + 0] = multiply_by_2[u0] ^ multiply_by_3[u1] ^ u2 ^ u3;
        res[4 * i + 1] = multiply_by_2[u1] ^ multiply_by_3[u2] ^ u3 ^ u0;
        res[4 * i + 2] = multiply_by_2[u2] ^ multiply_by_3[u3] ^ u0 ^ u1;
        res[4 * i + 3] = multiply_by_2[u3] ^ multiply_by_3[u0] ^ u1 ^ u2;
    }

    return res;
}

std::array<uint8_t, 16> AES128EncryptBlock(const std::array<uint8_t, 16>& block, const std::array<uint8_t, 16>& initial_key, const size_t rounds) {
    std::vector<uint8_t> expanded_key{};
    expanded_key.reserve(16 * (rounds + 1));

    for (size_t i = 0; i < 16; i++) {
        expanded_key.push_back(initial_key[i]);
    }

    const std::array<uint8_t, 256> forward_rijandael_s_box{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
    const std::array<uint8_t, 256> rcon{0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d};

    for (size_t i = 16; i < 16 * (rounds + 1); i+=4) {
        std::array<uint8_t, 4> temp{};

        if (i % 16 == 0) {
            temp[0] = forward_rijandael_s_box[expanded_key[i - 3]] ^ rcon[static_cast<uint8_t>(i / 16)];
            temp[1] = forward_rijandael_s_box[expanded_key[i - 2]];
            temp[2] = forward_rijandael_s_box[expanded_key[i - 1]];
            temp[3] = forward_rijandael_s_box[expanded_key[i - 4]];
        } else {
            temp[0] = expanded_key[i - 4];
            temp[1] = expanded_key[i - 3];
            temp[2] = expanded_key[i - 2];
            temp[3] = expanded_key[i - 1];
        }

        expanded_key.push_back(expanded_key[i - 16 + 0] ^ temp[0]);
        expanded_key.push_back(expanded_key[i - 16 + 1] ^ temp[1]);
        expanded_key.push_back(expanded_key[i - 16 + 2] ^ temp[2]);
        expanded_key.push_back(expanded_key[i - 16 + 3] ^ temp[3]);
    }

    std::array<uint8_t, 16> res{};
    std::array<uint8_t, 16> key{};

    res = block;
    
    for (size_t r = 0; r < (rounds - 1); r++) {
        for (size_t i = 0; i < 16; i++) {
            key[i] = expanded_key[16 * r + i];
        }
        
        res = AES128AddRoundKey(res, key);
        res = AES128SubBytes(res);
        res = AES128ShiftRows(res);
        res = AES128MixColumns(res);
    }
    
    for (size_t i = 0; i < 16; i++) {
        key[i] = expanded_key[16 * (rounds - 1) + i];
    }
    
    res = AES128AddRoundKey(res, key);
    res = AES128SubBytes(res);
    res = AES128ShiftRows(res);

    for (size_t i = 0; i < 16; i++) {
        key[i] = expanded_key[16 * rounds + i];
    }

    res = AES128AddRoundKey(res, key);

    return res;
}

std::array<uint8_t, 16> HexToBlock(const std::string& hex_string) {
    if (hex_string.length() != 32) {
        std::exit(1);
    }

    std::array<uint8_t, 16> res{};

    for (size_t i = 0; i < 16; i++) {
        uint8_t high = HexCharToUint(hex_string[2 * i]);
        uint8_t low = HexCharToUint(hex_string[2 * i + 1]);

        res[i] = (high << 4) | low;
    }

    return res;
}

std::string AES128ECBEncrypt(const std::string& s, const std::array<uint8_t, 16>& key, const size_t rounds) {
    if (s.length() % 32 != 0) {
        std::exit(1);
    }

    std::string res{};
    res.reserve(s.length() / 2);

    std::array<uint8_t, 16> encrypted_block{};

    for (size_t i = 0; (i + 32) <= s.length(); i += 32) {
        encrypted_block = AES128EncryptBlock(HexToBlock(s.substr(i, 32)), key, rounds);

        for (size_t j = 0; j < 16; j++) {
            res.push_back(static_cast<char>(encrypted_block[j]));
        }
    }

    return res;
}

std::string RandomString(size_t length) {
    std::string res{};
    res.reserve(length);

    for (size_t i = 0; i < length; i++) {
        res.push_back(rand());
    }

    return res;
}

std::string VulnerablePenguinEncrypt(const std::string& my_string, const std::string& random_prefix_string, const std::string& key_string) {
std::array<uint8_t, 16> key{
        static_cast<uint8_t>(key_string[0]),  static_cast<uint8_t>(key_string[1]),  static_cast<uint8_t>(key_string[2]),  static_cast<uint8_t>(key_string[3]), 
        static_cast<uint8_t>(key_string[4]),  static_cast<uint8_t>(key_string[5]),  static_cast<uint8_t>(key_string[6]),  static_cast<uint8_t>(key_string[7]), 
        static_cast<uint8_t>(key_string[8]),  static_cast<uint8_t>(key_string[9]),  static_cast<uint8_t>(key_string[10]), static_cast<uint8_t>(key_string[11]), 
        static_cast<uint8_t>(key_string[12]), static_cast<uint8_t>(key_string[13]), static_cast<uint8_t>(key_string[14]), static_cast<uint8_t>(key_string[15])
    };

    std::string secret_hex_string{Base64ToHex("Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK")};

    std::string input_hex_string{StringToHexString(random_prefix_string) + StringToHexString(my_string) + secret_hex_string};
    std::string padded_input_hex_string{input_hex_string + std::string(((32 * static_cast<size_t>((input_hex_string.length() + 31) / 32) - input_hex_string.length())), '0')};

    const int ROUNDS = 10;
    return AES128ECBEncrypt(padded_input_hex_string, key, ROUNDS);
}

int main() {
    size_t seed = time(NULL);
    srand(seed);
    std::cout << "srand seed: " << seed << std::endl;

    std::string random_prefix_string{RandomString(rand() % 50)};
    std::string key_string{RandomString(16)};
    
    bool block_size_and_offset_found = false;
    size_t probable_block_offset;
    size_t probable_block_size;
    for (size_t block_offset = 0; (block_offset < 64) && !block_size_and_offset_found; block_offset++) {
        for (size_t block_size = 4; (block_size <= 64) && !block_size_and_offset_found; block_size++) {
            std::string block_size_test{VulnerablePenguinEncrypt(RandomString(64 - block_offset + block_size) + std::string((2 * block_size), 'B'), random_prefix_string, key_string)};

            std::string ss_0 = block_size_test.substr(64 + block_size, block_size);
            std::string ss_1 = block_size_test.substr((64 + block_size + block_size), block_size);
            
            if (ss_0 == ss_1) {
                block_size_and_offset_found = true;
                probable_block_offset = block_offset;
                probable_block_size = block_size;
            }
        }
    }

    std::cout << "probable ECB, block offset: " << probable_block_offset << "  size: " << probable_block_size << std::endl;

    size_t secret_length = VulnerablePenguinEncrypt("", random_prefix_string, key_string).length() - probable_block_offset;
    std::string decrypted_penguin{};
    decrypted_penguin.reserve(secret_length);

    std::string known_padding_input{};
    known_padding_input.resize(probable_block_size, 'A');

    for (size_t i = 0; i < secret_length; i++) {
        std::string extra_padding((probable_block_size - (probable_block_offset % probable_block_size)), 'B');
        size_t combined_padding_size = probable_block_offset + extra_padding.length();
        std::string penguin_input_to_match{VulnerablePenguinEncrypt(extra_padding + known_padding_input.substr(0, (probable_block_size - (i % probable_block_size) - 1)), random_prefix_string, key_string).substr((combined_padding_size + 16 * static_cast<size_t>(i / 16)), 16)};

        for (unsigned c = 0; c < 256; c++) {
            known_padding_input[known_padding_input.length() - 1] = static_cast<char>(c);

            if (penguin_input_to_match == VulnerablePenguinEncrypt(extra_padding + known_padding_input, random_prefix_string, key_string).substr(combined_padding_size, 16)) {
                decrypted_penguin.push_back(static_cast<char>(c));
                known_padding_input[known_padding_input.length() - 1] = static_cast<char>(c);
                break;
            }
        }

        for (size_t j = 0; j < (known_padding_input.length() - 1); j++) {
            known_padding_input[j] = known_padding_input[j + 1];
        }
    }

    std::cout << decrypted_penguin << std::endl;

    return 0;
}